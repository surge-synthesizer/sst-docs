<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sst-filters: Filter Struct Reference</title>
<link rel="shortcut icon" href="logo.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115384200-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-115384200-1');
</script>
<!-- END Global site tag - Google Analytics -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px; padding-top: 5px; padding-bottom: 5px;">
  <td id="projectlogo"><a href="https://github.com/surge-synthesizer/sst-filters"><img alt="Logo" style="width: 100%; height: 100%" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sst-filters
<!--   BEGIN PROJECT_NUMBER&#160;<span id="projectnumber">1.0.0</span>END PROJECT_NUMBER-->
   </div>
   <div id="projectbrief">Filters submodule for the Surge Synthesizer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesst.html">sst</a></li><li class="navelem"><a class="el" href="namespacesst_1_1filtersplusplus.html">filtersplusplus</a></li><li class="navelem"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html">Filter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="structsst_1_1filtersplusplus_1_1Filter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Filter Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class representing the surge filter models with a easier-to-use api.  
 <a href="structsst_1_1filtersplusplus_1_1Filter.html#details">More...</a></p>

<p><code>#include &lt;api.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa54ecec72c96d310fae7c13d99d57e05" id="r_aa54ecec72c96d310fae7c13d99d57e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#aa54ecec72c96d310fae7c13d99d57e05">setFilterModel</a> (<a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a> model)</td></tr>
<tr class="separator:aa54ecec72c96d310fae7c13d99d57e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16958e979fdfe0cd240f218f646f1b52" id="r_a16958e979fdfe0cd240f218f646f1b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a16958e979fdfe0cd240f218f646f1b52">getFilterModel</a> () const</td></tr>
<tr class="separator:a16958e979fdfe0cd240f218f646f1b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1286366ff880145af13aa8f23b200b" id="r_acc1286366ff880145af13aa8f23b200b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#acc1286366ff880145af13aa8f23b200b">setPassType</a> (<a class="el" href="namespacesst_1_1filtersplusplus.html#a795343ba96350d0490da1819bafb4c9f">PassTypes</a> type)</td></tr>
<tr class="separator:acc1286366ff880145af13aa8f23b200b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcba9fb0fbece7899b8e1c93c7784d6a" id="r_afcba9fb0fbece7899b8e1c93c7784d6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#afcba9fb0fbece7899b8e1c93c7784d6a">setSlopeLevel</a> (<a class="el" href="namespacesst_1_1filtersplusplus.html#a375f9a2f522bbab65462b06181aaf0d6">SlopeLevels</a> slope)</td></tr>
<tr class="separator:afcba9fb0fbece7899b8e1c93c7784d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e28a45379426fb18a6cee9d8e0771fc" id="r_a9e28a45379426fb18a6cee9d8e0771fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a9e28a45379426fb18a6cee9d8e0771fc">setDriveType</a> (<a class="el" href="namespacesst_1_1filtersplusplus.html#a0489bf589191fe778eb6b15a4f03bfec">DriveTypes</a> drive)</td></tr>
<tr class="separator:a9e28a45379426fb18a6cee9d8e0771fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edadbd99b490d94dd55f34cd2561720" id="r_a5edadbd99b490d94dd55f34cd2561720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a5edadbd99b490d94dd55f34cd2561720">setSubModelType</a> (<a class="el" href="namespacesst_1_1filtersplusplus.html#ab794dae93eed6e1041d72f4d662b8c04">SubModelTypes</a> smt)</td></tr>
<tr class="separator:a5edadbd99b490d94dd55f34cd2561720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0d98ac46914b071915df3cbb3cd18b" id="r_a9d0d98ac46914b071915df3cbb3cd18b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a9d0d98ac46914b071915df3cbb3cd18b">setModelConfiguration</a> (const <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a> &amp;sk)</td></tr>
<tr class="separator:a9d0d98ac46914b071915df3cbb3cd18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713203944f561fcdb59a93d190a00ced" id="r_a713203944f561fcdb59a93d190a00ced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a713203944f561fcdb59a93d190a00ced">getModelConfiguration</a> () const</td></tr>
<tr class="separator:a713203944f561fcdb59a93d190a00ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303c04f07dc6a5e2264b3ad819cf9d27" id="r_a303c04f07dc6a5e2264b3ad819cf9d27"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a303c04f07dc6a5e2264b3ad819cf9d27">displayName</a> () const</td></tr>
<tr class="memdesc:a303c04f07dc6a5e2264b3ad819cf9d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reasonable user facing display name for the given configuration.  <br /></td></tr>
<tr class="separator:a303c04f07dc6a5e2264b3ad819cf9d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4c2d0445932659ae203d2d13ed54bc" id="r_aec4c2d0445932659ae203d2d13ed54bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#aec4c2d0445932659ae203d2d13ed54bc">provideDelayLine</a> (int voice, float *memory)</td></tr>
<tr class="memdesc:aec4c2d0445932659ae203d2d13ed54bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a delay line is needed, each active voice requires one.  <br /></td></tr>
<tr class="separator:aec4c2d0445932659ae203d2d13ed54bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eea6576af602cfa469da4e41b6a7c70" id="r_a0eea6576af602cfa469da4e41b6a7c70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a0eea6576af602cfa469da4e41b6a7c70">provideAllDelayLines</a> (float *memory)</td></tr>
<tr class="memdesc:a0eea6576af602cfa469da4e41b6a7c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Or provide them all in one go.  <br /></td></tr>
<tr class="separator:a0eea6576af602cfa469da4e41b6a7c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa4e6a77176ab13076a2af0a957c76e" id="r_a9fa4e6a77176ab13076a2af0a957c76e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a9fa4e6a77176ab13076a2af0a957c76e">getBlockSize</a> () const</td></tr>
<tr class="separator:a9fa4e6a77176ab13076a2af0a957c76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a300ef26cdb05b7b110fdc0dff4a06" id="r_a33a300ef26cdb05b7b110fdc0dff4a06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a33a300ef26cdb05b7b110fdc0dff4a06">prepareInstance</a> ()</td></tr>
<tr class="memdesc:a33a300ef26cdb05b7b110fdc0dff4a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once a filter has been set up with a model type and a configuration the instance needs preparation to resolve the internal state.  <br /></td></tr>
<tr class="separator:a33a300ef26cdb05b7b110fdc0dff4a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e837634d6cb6e4d61b3d1a739a17358" id="r_a1e837634d6cb6e4d61b3d1a739a17358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a1e837634d6cb6e4d61b3d1a739a17358">requiresPreparation</a> () const</td></tr>
<tr class="memdesc:a1e837634d6cb6e4d61b3d1a739a17358"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a call to prepareInstance is required, this will return true.  <br /></td></tr>
<tr class="separator:a1e837634d6cb6e4d61b3d1a739a17358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae198aacaa2a4d55f3ece665390022137" id="r_ae198aacaa2a4d55f3ece665390022137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ae198aacaa2a4d55f3ece665390022137">makeCoefficients</a> (int voice, float cutoff, float resonance, float extra=0.f, float extra2=0.f, float extra3=0.f)</td></tr>
<tr class="memdesc:ae198aacaa2a4d55f3ece665390022137"><td class="mdescLeft">&#160;</td><td class="mdescRight">With a given voice, for a given cutoff and resonance, set the internal coefficient state.  <br /></td></tr>
<tr class="separator:ae198aacaa2a4d55f3ece665390022137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a350d1ff0c7c85da0ab75c37a828d48" id="r_a1a350d1ff0c7c85da0ab75c37a828d48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a1a350d1ff0c7c85da0ab75c37a828d48">copyCoefficientsFromVoiceToVoice</a> (int from, int to)</td></tr>
<tr class="memdesc:a1a350d1ff0c7c85da0ab75c37a828d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want two voices to share coefficients - so a stereo pair with the same cutoff and resonance for instance - it is usually faster to copy coefficients from voice A to voice B that it is to compute them twice.  <br /></td></tr>
<tr class="separator:a1a350d1ff0c7c85da0ab75c37a828d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206bb7e05b0f4d6eb38d43f05937c85b" id="r_a206bb7e05b0f4d6eb38d43f05937c85b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a206bb7e05b0f4d6eb38d43f05937c85b">makeConstantCoefficients</a> (int voice, float cutoff, float resonance, float extra=0.f, float extra2=0.f, float extra3=0.f)</td></tr>
<tr class="memdesc:a206bb7e05b0f4d6eb38d43f05937c85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">With a given voice, for a given cutoff and resonance, set the internal coefficient state.  <br /></td></tr>
<tr class="separator:a206bb7e05b0f4d6eb38d43f05937c85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b65d36444ad7485b486fc877a14ba40" id="r_a4b65d36444ad7485b486fc877a14ba40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a4b65d36444ad7485b486fc877a14ba40">setActive</a> (int voice, bool b)</td></tr>
<tr class="memdesc:a4b65d36444ad7485b486fc877a14ba40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filters can have a concept of an inactive voice which for some filters give a moderate CPU advantage in the SIMD pipelines.  <br /></td></tr>
<tr class="separator:a4b65d36444ad7485b486fc877a14ba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162e7ed84106548023e94375fa21500c" id="r_a162e7ed84106548023e94375fa21500c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a162e7ed84106548023e94375fa21500c">setMono</a> ()</td></tr>
<tr class="separator:a162e7ed84106548023e94375fa21500c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17e658b8475abf47280708f5460829b" id="r_ad17e658b8475abf47280708f5460829b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ad17e658b8475abf47280708f5460829b">setStereo</a> ()</td></tr>
<tr class="separator:ad17e658b8475abf47280708f5460829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2992b6e0fcf85997799c3ac0be779d8c" id="r_a2992b6e0fcf85997799c3ac0be779d8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a2992b6e0fcf85997799c3ac0be779d8c">setQuad</a> ()</td></tr>
<tr class="separator:a2992b6e0fcf85997799c3ac0be779d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa4ebe01a2db1d1ada9aef3499cb086" id="r_a3aa4ebe01a2db1d1ada9aef3499cb086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a3aa4ebe01a2db1d1ada9aef3499cb086">setSampleRateAndBlockSize</a> (double sampleRate, size_t blockSize)</td></tr>
<tr class="separator:a3aa4ebe01a2db1d1ada9aef3499cb086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6518ed8373b1494d461f3b900dd0e5d" id="r_aa6518ed8373b1494d461f3b900dd0e5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#aa6518ed8373b1494d461f3b900dd0e5d">prepareBlock</a> ()</td></tr>
<tr class="memdesc:aa6518ed8373b1494d461f3b900dd0e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepareBlock must be called after coeffients are set but at the start of each block, as set by blockSize in setSampleRateAndBlockSize  <br /></td></tr>
<tr class="separator:aa6518ed8373b1494d461f3b900dd0e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd5054af97c8e78764b4981e0305d13" id="r_a3cd5054af97c8e78764b4981e0305d13"><td class="memItemLeft" align="right" valign="top">SIMD_M128&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a3cd5054af97c8e78764b4981e0305d13">processSample</a> (SIMD_M128 in)</td></tr>
<tr class="memdesc:a3cd5054af97c8e78764b4981e0305d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">once prepare block has been called, you must call processSample exactly blockSize times, mapping the vector value in to the vector value out.  <br /></td></tr>
<tr class="separator:a3cd5054af97c8e78764b4981e0305d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ece8404ddc3df4400951bcd6a2b90e" id="r_ae8ece8404ddc3df4400951bcd6a2b90e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ae8ece8404ddc3df4400951bcd6a2b90e">concludeBlock</a> ()</td></tr>
<tr class="memdesc:ae8ece8404ddc3df4400951bcd6a2b90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">At the end of blockSize samples, and before resetting coefficients or the next call to prepareBlock, you need to call concludeBlock.  <br /></td></tr>
<tr class="separator:ae8ece8404ddc3df4400951bcd6a2b90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d48444d32cd02ed218776a0e5cdba4" id="r_ab8d48444d32cd02ed218776a0e5cdba4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ab8d48444d32cd02ed218776a0e5cdba4">processMonoSample</a> (float in)</td></tr>
<tr class="memdesc:ab8d48444d32cd02ed218776a0e5cdba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience functions for mono channel if you dont want to manage simd  <br /></td></tr>
<tr class="separator:ab8d48444d32cd02ed218776a0e5cdba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3edce36cb488ab5dfc911265cc9e7ae" id="r_ae3edce36cb488ab5dfc911265cc9e7ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ae3edce36cb488ab5dfc911265cc9e7ae">processStereoSample</a> (float inL, float inR, float &amp;outL, float &amp;outR)</td></tr>
<tr class="memdesc:ae3edce36cb488ab5dfc911265cc9e7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience functions for stereo channel if you dont want to manage simd  <br /></td></tr>
<tr class="separator:ae3edce36cb488ab5dfc911265cc9e7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aad8ae266f2f323132e8414254797de" id="r_a1aad8ae266f2f323132e8414254797de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a1aad8ae266f2f323132e8414254797de">processQuadSample</a> (float in[4], float out[4])</td></tr>
<tr class="memdesc:a1aad8ae266f2f323132e8414254797de"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience functions for quad channel if you dont want to manage simd.  <br /></td></tr>
<tr class="separator:a1aad8ae266f2f323132e8414254797de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fd73d861ef2e4aabb38c0c9ff82947" id="r_a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr class="memdesc:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the filter state.  <br /></td></tr>
<tr class="separator:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20897c5c8bd47f5d4005989bead0e55" id="r_ad20897c5c8bd47f5d4005989bead0e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ad20897c5c8bd47f5d4005989bead0e55">reset</a> ()</td></tr>
<tr class="memdesc:ad20897c5c8bd47f5d4005989bead0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the filter registers; leaves the rest of the state intact.  <br /></td></tr>
<tr class="separator:ad20897c5c8bd47f5d4005989bead0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac0dd72c059683ae15da44456ccfc49dd" id="r_ac0dd72c059683ae15da44456ccfc49dd"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ac0dd72c059683ae15da44456ccfc49dd">requiredDelayLinesSizes</a> (<a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a> model, const <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a> &amp;k)</td></tr>
<tr class="memdesc:ac0dd72c059683ae15da44456ccfc49dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some model types require a float buffer for a delay line.  <br /></td></tr>
<tr class="separator:ac0dd72c059683ae15da44456ccfc49dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60e1aa53db794a1966db4505fcc2730" id="r_aa60e1aa53db794a1966db4505fcc2730"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#aa60e1aa53db794a1966db4505fcc2730">coefficientsExtraCount</a> (<a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a> model, const <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a> &amp;c)</td></tr>
<tr class="memdesc:aa60e1aa53db794a1966db4505fcc2730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some models have coefficient features beyond jsut cutoff and resonance.  <br /></td></tr>
<tr class="separator:aa60e1aa53db794a1966db4505fcc2730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da9062fdf386cdde208180a1987fc6" id="r_af1da9062fdf386cdde208180a1987fc6"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#af1da9062fdf386cdde208180a1987fc6">availableModels</a> ()</td></tr>
<tr class="memdesc:af1da9062fdf386cdde208180a1987fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of the available models supported by the API.  <br /></td></tr>
<tr class="separator:af1da9062fdf386cdde208180a1987fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bed5d143d6b4f54bf03abb4e9725cc" id="r_a86bed5d143d6b4f54bf03abb4e9725cc"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a86bed5d143d6b4f54bf03abb4e9725cc">availableModelConfigurations</a> (<a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a> model, bool sort=false)</td></tr>
<tr class="memdesc:a86bed5d143d6b4f54bf03abb4e9725cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given model, return the configurations that model supports.  <br /></td></tr>
<tr class="separator:a86bed5d143d6b4f54bf03abb4e9725cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a91387e3bd5ec72538c8cc5759ae3e21c" id="r_a91387e3bd5ec72538c8cc5759ae3e21c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html">details::FilterPayload</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">payload</a></td></tr>
<tr class="separator:a91387e3bd5ec72538c8cc5759ae3e21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class representing the surge filter models with a easier-to-use api. </p>
<p>The <code><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html" title="A class representing the surge filter models with a easier-to-use api.">Filter</a></code> class provides an easier to use and enumerated interface on the existing surge filter models, which previously had a direct more-C-style interface and a relatively flat list of feature lookup capabilities. Both APIs are still supported, and the <code><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html" title="A class representing the surge filter models with a easier-to-use api.">Filter</a></code> api is a wrapper on that more mechanical underlying API.</p>
<p>The <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html" title="A class representing the surge filter models with a easier-to-use api.">Filter</a> is configured in a two-part hierarchy, which is specified in <code><a class="el" href="enums_8h.html">enums.h</a></code>.</p>
<p>The top of the heirarchy is the <code>FilterModels</code> enum. That provides the classes of filters which surge provides. The method <code>Filter::availableFilterModels()</code> returns you a list of them.</p>
<p>Once you have a model, the model is configured by a tuple of {passtype, slopelevel, drivetype, submodel} each of which is a separate enum. Any of these can be left out (or set to <code>UNSUPPORTED</code>). So for instance, the model <code><a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa6c779722bd0b5405629d680c27f22a02">FilterModels::VemberClassic</a></code> has a configuration <code>{<a class="el" href="namespacesst_1_1filtersplusplus.html#a795343ba96350d0490da1819bafb4c9fa233724c5adf28da47784390134db3c66">PassTypes::LP</a>, SlopeLeveLs::Slope_12db, <a class="el" href="namespacesst_1_1filtersplusplus.html#a0489bf589191fe778eb6b15a4f03bfeca37d12e2cfbef6e6105297374d02f3998">DriveTypes::Clean</a>}</code>. You can enumerate all the configuration tuples ysing <code><a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a86bed5d143d6b4f54bf03abb4e9725cc" title="For a given model, return the configurations that model supports.">Filter::availableModelConfigurations()</a></code>.</p>
<p>Each of the filters is implemented to simultaneously run 4-wide SIMD on a vector of 4 floats in to 4 floats out. While a filter must have a consistent model across the voices, it can have varied resonances and cutoffs, so some apis take a voice parameter.</p>
<p>Finally the surge filters work on a two-rate principle, where there is a control rate block at which you can reset coefficients and a sample-rate api. Managing these two rates is possible with the API and is the responsibility of the API caller. At the outset of a block after setting coefficients, call prepareBlock, and at the conclusion of the block, call concludeBlock.</p>
<p>As such a typical session could look something like this</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>sfpp = <a class="code hl_namespace" href="namespacesst_1_1filtersplusplus.html">sst::filtersplusplus</a>;</div>
<div class="line"><span class="keyword">auto</span> filter = sfpp::Filter();</div>
<div class="line"> </div>
<div class="line">filter.setSampleRateAndBlockSize(48000, 16);</div>
<div class="line"> </div>
<div class="line">filter.setFilterModel(sfpp::FilterModels::OBXD_4Pole);</div>
<div class="line">filter.setPassType(sfpp::PassTypes::LP);</div>
<div class="line">filter.setSlopeLevel(sfpp::SlopeLevels::Slope_18db);</div>
<div class="line"><span class="keywordflow">if</span> (!filter.prepareInstance())</div>
<div class="line">    <a class="code hl_define" href="catch2_8hpp.html#ad57835ba8f1bb419a865ada6bd011a85">REQUIRE</a>(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> blockPos{0};</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;100; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (blockPos == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v=0; v&lt;4; ++v)</div>
<div class="line">        {</div>
<div class="line">            filter.makeCoefficients(v, -9, 0.1 + v * 0.2);</div>
<div class="line">        }</div>
<div class="line">        filter.prepareBlock();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> out = filter.processSample(SIMD_MM(setzero_ps)());</div>
<div class="line"> </div>
<div class="line">    blockPos ++;</div>
<div class="line">    <span class="keywordflow">if</span> (blockPos == filter.getBlockSize())</div>
<div class="line">    {</div>
<div class="line">        filter.concludeBlock();</div>
<div class="line">        blockPos = 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="acatch2_8hpp_html_ad57835ba8f1bb419a865ada6bd011a85"><div class="ttname"><a href="catch2_8hpp.html#ad57835ba8f1bb419a865ada6bd011a85">REQUIRE</a></div><div class="ttdeci">#define REQUIRE(...)</div><div class="ttdef"><b>Definition</b> catch2.hpp:17659</div></div>
<div class="ttc" id="anamespacesst_1_1filtersplusplus_html"><div class="ttname"><a href="namespacesst_1_1filtersplusplus.html">sst::filtersplusplus</a></div><div class="ttdef"><b>Definition</b> api.h:28</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa54ecec72c96d310fae7c13d99d57e05" name="aa54ecec72c96d310fae7c13d99d57e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54ecec72c96d310fae7c13d99d57e05">&#9670;&#160;</a></span>setFilterModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFilterModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a>&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#aa54ecec72c96d310fae7c13d99d57e05">FilterPayload::setFilterModel()</a>.</p>

</div>
</div>
<a id="a16958e979fdfe0cd240f218f646f1b52" name="a16958e979fdfe0cd240f218f646f1b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16958e979fdfe0cd240f218f646f1b52">&#9670;&#160;</a></span>getFilterModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a> getFilterModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a543231174134bf5dff2ad859f68982a6">FilterPayload::filterModel</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>.</p>

<p class="reference">Referenced by <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a33a300ef26cdb05b7b110fdc0dff4a06">Filter::prepareInstance()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a0eea6576af602cfa469da4e41b6a7c70">Filter::provideAllDelayLines()</a>.</p>

</div>
</div>
<a id="acc1286366ff880145af13aa8f23b200b" name="acc1286366ff880145af13aa8f23b200b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1286366ff880145af13aa8f23b200b">&#9670;&#160;</a></span>setPassType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPassType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesst_1_1filtersplusplus.html#a795343ba96350d0490da1819bafb4c9f">PassTypes</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#acc1286366ff880145af13aa8f23b200b">FilterPayload::setPassType()</a>.</p>

</div>
</div>
<a id="afcba9fb0fbece7899b8e1c93c7784d6a" name="afcba9fb0fbece7899b8e1c93c7784d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcba9fb0fbece7899b8e1c93c7784d6a">&#9670;&#160;</a></span>setSlopeLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSlopeLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesst_1_1filtersplusplus.html#a375f9a2f522bbab65462b06181aaf0d6">SlopeLevels</a>&#160;</td>
          <td class="paramname"><em>slope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#afcba9fb0fbece7899b8e1c93c7784d6a">FilterPayload::setSlopeLevel()</a>.</p>

</div>
</div>
<a id="a9e28a45379426fb18a6cee9d8e0771fc" name="a9e28a45379426fb18a6cee9d8e0771fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e28a45379426fb18a6cee9d8e0771fc">&#9670;&#160;</a></span>setDriveType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDriveType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesst_1_1filtersplusplus.html#a0489bf589191fe778eb6b15a4f03bfec">DriveTypes</a>&#160;</td>
          <td class="paramname"><em>drive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a9e28a45379426fb18a6cee9d8e0771fc">FilterPayload::setDriveType()</a>.</p>

</div>
</div>
<a id="a5edadbd99b490d94dd55f34cd2561720" name="a5edadbd99b490d94dd55f34cd2561720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edadbd99b490d94dd55f34cd2561720">&#9670;&#160;</a></span>setSubModelType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSubModelType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesst_1_1filtersplusplus.html#ab794dae93eed6e1041d72f4d662b8c04">SubModelTypes</a>&#160;</td>
          <td class="paramname"><em>smt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#af71a07bfdbd2a1d23218d16b0bea7ebc">FilterPayload::setSubModelType()</a>.</p>

</div>
</div>
<a id="a9d0d98ac46914b071915df3cbb3cd18b" name="a9d0d98ac46914b071915df3cbb3cd18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0d98ac46914b071915df3cbb3cd18b">&#9670;&#160;</a></span>setModelConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setModelConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a54ca87e0379fc6c8ac2e385f080d1c9e">FilterPayload::setModelConfiguration()</a>.</p>

</div>
</div>
<a id="a713203944f561fcdb59a93d190a00ced" name="a713203944f561fcdb59a93d190a00ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713203944f561fcdb59a93d190a00ced">&#9670;&#160;</a></span>getModelConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a> getModelConfiguration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a713203944f561fcdb59a93d190a00ced">FilterPayload::getModelConfiguration()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>.</p>

<p class="reference">Referenced by <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a33a300ef26cdb05b7b110fdc0dff4a06">Filter::prepareInstance()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a0eea6576af602cfa469da4e41b6a7c70">Filter::provideAllDelayLines()</a>.</p>

</div>
</div>
<a id="a303c04f07dc6a5e2264b3ad819cf9d27" name="a303c04f07dc6a5e2264b3ad819cf9d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303c04f07dc6a5e2264b3ad819cf9d27">&#9670;&#160;</a></span>displayName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string displayName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A reasonable user facing display name for the given configuration. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a303c04f07dc6a5e2264b3ad819cf9d27">FilterPayload::displayName()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>.</p>

</div>
</div>
<a id="ac0dd72c059683ae15da44456ccfc49dd" name="ac0dd72c059683ae15da44456ccfc49dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dd72c059683ae15da44456ccfc49dd">&#9670;&#160;</a></span>requiredDelayLinesSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t requiredDelayLinesSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some model types require a float buffer for a delay line. </p>
<p>We assume this relatively large chunk of memory will be managed outside this object. This api returns 0 if no such buffer is required, and the requires size in 32 big floats if so. Currently only the comb filter models require this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>Which model </td></tr>
    <tr><td class="paramname">k</td><td>Configured how </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>how many floats must the delay line have </dd></dl>

<p class="reference">References <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa727a6902aa157bdec751ce0739490899">sst::filtersplusplus::Comb</a>, <a class="el" href="structsst_1_1filters_1_1utilities_1_1SincTable.html#a15359e2a654ffb243c65ec8093145190">SincTable::FIRipol_N</a>, and <a class="el" href="namespacesst_1_1filters_1_1utilities.html#a233f4adbca294cf570eaa34f52b0e6d1">sst::filters::utilities::MAX_FB_COMB</a>.</p>

<p class="reference">Referenced by <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a33a300ef26cdb05b7b110fdc0dff4a06">Filter::prepareInstance()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a0eea6576af602cfa469da4e41b6a7c70">Filter::provideAllDelayLines()</a>.</p>

</div>
</div>
<a id="aec4c2d0445932659ae203d2d13ed54bc" name="aec4c2d0445932659ae203d2d13ed54bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4c2d0445932659ae203d2d13ed54bc">&#9670;&#160;</a></span>provideDelayLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void provideDelayLine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a delay line is needed, each active voice requires one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voice</td><td>Each voice needs a distinct buffer </td></tr>
    <tr><td class="paramname">memory</td><td>This is a pointer to memory which is not owned by this object and must outlive it </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a5d415bfcb027ba138551cd8d6eea2428">FilterPayload::provideDelayLine()</a>.</p>

</div>
</div>
<a id="a0eea6576af602cfa469da4e41b6a7c70" name="a0eea6576af602cfa469da4e41b6a7c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eea6576af602cfa469da4e41b6a7c70">&#9670;&#160;</a></span>provideAllDelayLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void provideAllDelayLines </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Or provide them all in one go. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a16958e979fdfe0cd240f218f646f1b52">Filter::getFilterModel()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a713203944f561fcdb59a93d190a00ced">Filter::getModelConfiguration()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a5d415bfcb027ba138551cd8d6eea2428">FilterPayload::provideDelayLine()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ac0dd72c059683ae15da44456ccfc49dd">Filter::requiredDelayLinesSizes()</a>.</p>

</div>
</div>
<a id="a9fa4e6a77176ab13076a2af0a957c76e" name="a9fa4e6a77176ab13076a2af0a957c76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa4e6a77176ab13076a2af0a957c76e">&#9670;&#160;</a></span>getBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t getBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#aa219775c20ca1c090756a777840c0c58">FilterPayload::blockSize</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>.</p>

</div>
</div>
<a id="aa60e1aa53db794a1966db4505fcc2730" name="aa60e1aa53db794a1966db4505fcc2730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60e1aa53db794a1966db4505fcc2730">&#9670;&#160;</a></span>coefficientsExtraCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int coefficientsExtraCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some models have coefficient features beyond jsut cutoff and resonance. </p>
<p>For instance the OBXD 4 pole low pass has a continous pole morphing mode (<a class="el" href="namespacesst_1_1filtersplusplus.html#a375f9a2f522bbab65462b06181aaf0d6acee36f0e37f01bafe97f6788d1fb0206">SlopeLevels::Slope_Morph</a>). In that case you will need to provide the 'extra' arguments to the makeCoefficients call to get the feature. This function tells you how manu such 'extra' arguments are consumed for a given model/config. </p>

<p class="reference">References <a class="el" href="namespacesst_1_1filtersplusplus.html#a795343ba96350d0490da1819bafb4c9fa999a06f28346262ef9e1699d9fc1ab56">sst::filtersplusplus::Bell</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa727a6902aa157bdec751ce0739490899">sst::filtersplusplus::Comb</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a375f9a2f522bbab65462b06181aaf0d6a23d73e7340fad352d4a11ff3be93534c">sst::filtersplusplus::Comb_Bipolar_ContinuousMix</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa7be04ac8d301f0cfdd3fe9f693e4fd16">sst::filtersplusplus::CytomicSVF</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html#aea07705e16c285908c394e9e483cf3d3">ModelConfig::dt</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a795343ba96350d0490da1819bafb4c9faaafe3de5c829706a2fda73dd43fd740e">sst::filtersplusplus::HighShelf</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa550ecafcd47776fc50b37277c3480ffd">sst::filtersplusplus::K35</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a0489bf589191fe778eb6b15a4f03bfecabb473aefe2471e3f4a2b3ee92294108e">sst::filtersplusplus::K35_Continuous</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a795343ba96350d0490da1819bafb4c9fa04efcd6f392567e252822d1247d8c875">sst::filtersplusplus::LowShelf</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa51dfac0ccef5bd25bb26c235f1aa7d92">sst::filtersplusplus::OBXD_4Pole</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html#af6902c44b762247517913cd83887a32e">ModelConfig::pt</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a375f9a2f522bbab65462b06181aaf0d6acee36f0e37f01bafe97f6788d1fb0206">sst::filtersplusplus::Slope_Morph</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html#af9bff73e2fcd0c9795f19a3916ef38d9">ModelConfig::st</a>.</p>

</div>
</div>
<a id="af1da9062fdf386cdde208180a1987fc6" name="af1da9062fdf386cdde208180a1987fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1da9062fdf386cdde208180a1987fc6">&#9670;&#160;</a></span>availableModels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a> &gt; availableModels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a list of the available models supported by the API. </p>

<p class="reference">References <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa727a6902aa157bdec751ce0739490899">sst::filtersplusplus::Comb</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa5043df1dd7d25d8f5d80106fb8ec93da">sst::filtersplusplus::CutoffWarp</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa7be04ac8d301f0cfdd3fe9f693e4fd16">sst::filtersplusplus::CytomicSVF</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffacc7fde190d78c538311c547b2cf4e1ed">sst::filtersplusplus::DiodeLadder</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa550ecafcd47776fc50b37277c3480ffd">sst::filtersplusplus::K35</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa3332df7833bb6d951f20615e6b22fbfa">sst::filtersplusplus::OBXD_2Pole</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa51dfac0ccef5bd25bb26c235f1aa7d92">sst::filtersplusplus::OBXD_4Pole</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffaafff2d8f38f1cee71436cb4504da0244">sst::filtersplusplus::OBXD_XPander</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffafbd5273d0efe403bd457c6a46ddf72f4">sst::filtersplusplus::ResonanceWarp</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa7b1d44f330826d642a6ade492ca28031">sst::filtersplusplus::SampleAndHold</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa0fc3dc9bb40a8f6e9d3c5299c6bdac86">sst::filtersplusplus::TriPole</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa3a8884a58bb4741c28f91e2e10904143">sst::filtersplusplus::VemberAllPass</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa6c779722bd0b5405629d680c27f22a02">sst::filtersplusplus::VemberClassic</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffac28fc8e66f8645d7b3d726a16224aa97">sst::filtersplusplus::VemberLadder</a>, and <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffa2fc520883f1d4838eb363fd1c0d38a85">sst::filtersplusplus::VintageLadder</a>.</p>

</div>
</div>
<a id="a86bed5d143d6b4f54bf03abb4e9725cc" name="a86bed5d143d6b4f54bf03abb4e9725cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bed5d143d6b4f54bf03abb4e9725cc">&#9670;&#160;</a></span>availableModelConfigurations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="structsst_1_1filtersplusplus_1_1ModelConfig.html">ModelConfig</a> &gt; availableModelConfigurations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ff">FilterModels</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given model, return the configurations that model supports. </p>
<p>The list by default will be unsorted, but the sort option allows you to sort it. Note that this is an allocating API to make that vector so you dont want to use it while processing. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#afb1a04a4f807164fe959822bdd5e6ec4">FilterPayload::availableModelConfigurations()</a>.</p>

</div>
</div>
<a id="a33a300ef26cdb05b7b110fdc0dff4a06" name="a33a300ef26cdb05b7b110fdc0dff4a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a300ef26cdb05b7b110fdc0dff4a06">&#9670;&#160;</a></span>prepareInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool prepareInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once a filter has been set up with a model type and a configuration the instance needs preparation to resolve the internal state. </p>
<p>This function will do so and will return true on success </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a8c344fd8f5fc88ef8674d295fdbe5353">FilterPayload::externalDelayLines</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a543231174134bf5dff2ad859f68982a6">FilterPayload::filterModel</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a42572c7ca045c47660c91effd101b31a">FilterPayload::func</a>, <a class="el" href="namespacesst_1_1filters.html#a7ef0ab496f57e183b484e62e2053c94fa2064b26f0af5c1e34074ca551af4c620">sst::filters::fut_none</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a16958e979fdfe0cd240f218f646f1b52">Filter::getFilterModel()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a713203944f561fcdb59a93d190a00ced">Filter::getModelConfiguration()</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a81e581586e5832eaa622b493223cf9ffad15305d7a4e34e02489c74a5ef542f36">sst::filtersplusplus::Off</a>, <a class="el" href="namespacesst_1_1filtersplusplus.html#a2ca7d88599ec2d90d69b0327c996a516">sst::filtersplusplus::offFun()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ac0dd72c059683ae15da44456ccfc49dd">Filter::requiredDelayLinesSizes()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ad20897c5c8bd47f5d4005989bead0e55">Filter::reset()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#ab97e38b869f89ae935465387dc42b7aa">FilterPayload::resolveLegacyType()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a28e3c179a86f337095088b3ca02a2b2a">FilterPayload::valid</a>.</p>

</div>
</div>
<a id="a1e837634d6cb6e4d61b3d1a739a17358" name="a1e837634d6cb6e4d61b3d1a739a17358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e837634d6cb6e4d61b3d1a739a17358">&#9670;&#160;</a></span>requiresPreparation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool requiresPreparation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a call to prepareInstance is required, this will return true. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a28e3c179a86f337095088b3ca02a2b2a">FilterPayload::valid</a>.</p>

</div>
</div>
<a id="ae198aacaa2a4d55f3ece665390022137" name="ae198aacaa2a4d55f3ece665390022137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae198aacaa2a4d55f3ece665390022137">&#9670;&#160;</a></span>makeCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void makeCoefficients </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>resonance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>extra</em> = <code>0.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>extra2</em> = <code>0.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>extra3</em> = <code>0.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>With a given voice, for a given cutoff and resonance, set the internal coefficient state. </p>
<p>This method will allow you to interpolate over blocks so is appropriate for per-block modification of coefficients, but as a result must be called every block before prepareBlock. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#ab3b7fcaf43da0551b4cbd565b761c47d">FilterPayload::currentLegacyType</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a543231174134bf5dff2ad859f68982a6">FilterPayload::filterModel</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a4060ca5aa1b55f315dd1a3aa21f2d7e1">FilterPayload::makers</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a28e3c179a86f337095088b3ca02a2b2a">FilterPayload::valid</a>.</p>

<p class="reference">Referenced by <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a206bb7e05b0f4d6eb38d43f05937c85b">Filter::makeConstantCoefficients()</a>.</p>

</div>
</div>
<a id="a1a350d1ff0c7c85da0ab75c37a828d48" name="a1a350d1ff0c7c85da0ab75c37a828d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a350d1ff0c7c85da0ab75c37a828d48">&#9670;&#160;</a></span>copyCoefficientsFromVoiceToVoice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copyCoefficientsFromVoiceToVoice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you want two voices to share coefficients - so a stereo pair with the same cutoff and resonance for instance - it is usually faster to copy coefficients from voice A to voice B that it is to compute them twice. </p>
<p>The voices retain independent registers of course, so will still do stereo or quad processing. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a4060ca5aa1b55f315dd1a3aa21f2d7e1">FilterPayload::makers</a>, <a class="el" href="namespacesst_1_1filters.html#a0e477c7b1b57147e6b307cdae7ba4bf1">sst::filters::n_cm_coeffs</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>.</p>

</div>
</div>
<a id="a206bb7e05b0f4d6eb38d43f05937c85b" name="a206bb7e05b0f4d6eb38d43f05937c85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206bb7e05b0f4d6eb38d43f05937c85b">&#9670;&#160;</a></span>makeConstantCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void makeConstantCoefficients </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>resonance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>extra</em> = <code>0.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>extra2</em> = <code>0.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>extra3</em> = <code>0.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>With a given voice, for a given cutoff and resonance, set the internal coefficient state. </p>
<p>This method will assume the coefficients are fixed and so is appropriate for static filter configurations and only needs to be called once, between prepareInstance and prepareBlock, but is not suitable for dynamically changing cutoff and resonance. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ae198aacaa2a4d55f3ece665390022137">Filter::makeCoefficients()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a4060ca5aa1b55f315dd1a3aa21f2d7e1">FilterPayload::makers</a>, <a class="el" href="namespacesst_1_1filters.html#a0e477c7b1b57147e6b307cdae7ba4bf1">sst::filters::n_cm_coeffs</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>.</p>

</div>
</div>
<a id="a4b65d36444ad7485b486fc877a14ba40" name="a4b65d36444ad7485b486fc877a14ba40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b65d36444ad7485b486fc877a14ba40">&#9670;&#160;</a></span>setActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setActive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The filters can have a concept of an inactive voice which for some filters give a moderate CPU advantage in the SIMD pipelines. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a0b56151486effa654591f0ae4106c8e6">FilterPayload::active</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>.</p>

<p class="reference">Referenced by <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a162e7ed84106548023e94375fa21500c">Filter::setMono()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a2992b6e0fcf85997799c3ac0be779d8c">Filter::setQuad()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ad17e658b8475abf47280708f5460829b">Filter::setStereo()</a>.</p>

</div>
</div>
<a id="a162e7ed84106548023e94375fa21500c" name="a162e7ed84106548023e94375fa21500c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162e7ed84106548023e94375fa21500c">&#9670;&#160;</a></span>setMono()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMono </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a4b65d36444ad7485b486fc877a14ba40">Filter::setActive()</a>.</p>

</div>
</div>
<a id="ad17e658b8475abf47280708f5460829b" name="ad17e658b8475abf47280708f5460829b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17e658b8475abf47280708f5460829b">&#9670;&#160;</a></span>setStereo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setStereo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a4b65d36444ad7485b486fc877a14ba40">Filter::setActive()</a>.</p>

</div>
</div>
<a id="a2992b6e0fcf85997799c3ac0be779d8c" name="a2992b6e0fcf85997799c3ac0be779d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2992b6e0fcf85997799c3ac0be779d8c">&#9670;&#160;</a></span>setQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setQuad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a4b65d36444ad7485b486fc877a14ba40">Filter::setActive()</a>.</p>

</div>
</div>
<a id="a3aa4ebe01a2db1d1ada9aef3499cb086" name="a3aa4ebe01a2db1d1ada9aef3499cb086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa4ebe01a2db1d1ada9aef3499cb086">&#9670;&#160;</a></span>setSampleRateAndBlockSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSampleRateAndBlockSize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a3aa4ebe01a2db1d1ada9aef3499cb086">FilterPayload::setSampleRateAndBlockSize()</a>.</p>

</div>
</div>
<a id="aa6518ed8373b1494d461f3b900dd0e5d" name="aa6518ed8373b1494d461f3b900dd0e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6518ed8373b1494d461f3b900dd0e5d">&#9670;&#160;</a></span>prepareBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prepareBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepareBlock must be called after coeffients are set but at the start of each block, as set by blockSize in setSampleRateAndBlockSize </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a0b56151486effa654591f0ae4106c8e6">FilterPayload::active</a>, <a class="el" href="structsst_1_1filters_1_1QuadFilterUnitState.html#a2d3de04291e527c7ae6fc9a8bedfb43e">QuadFilterUnitState::active</a>, <a class="el" href="structsst_1_1filters_1_1QuadFilterUnitState.html#a219bf64369e54895ac69d4bb64164fec">QuadFilterUnitState::DB</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a8c344fd8f5fc88ef8674d295fdbe5353">FilterPayload::externalDelayLines</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a4060ca5aa1b55f315dd1a3aa21f2d7e1">FilterPayload::makers</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a5214b86fecca5a3b820b08bc789ee35f">FilterPayload::qfuState</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a2bd79d2ab2dfb6aeaf75c2878ad30e1f">FilterPayload::sampleRate</a>, <a class="el" href="structsst_1_1filters_1_1QuadFilterUnitState.html#af6a61da668f2188e2850eba261e217c4">QuadFilterUnitState::sampleRate</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#aecd543acbff4461ac91af0ab900a716f">FilterPayload::sampleRateInv</a>, and <a class="el" href="structsst_1_1filters_1_1QuadFilterUnitState.html#a609377316c3dd00ffe5967549aa864f1">QuadFilterUnitState::sampleRateInv</a>.</p>

</div>
</div>
<a id="a3cd5054af97c8e78764b4981e0305d13" name="a3cd5054af97c8e78764b4981e0305d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd5054af97c8e78764b4981e0305d13">&#9670;&#160;</a></span>processSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIMD_M128 processSample </td>
          <td>(</td>
          <td class="paramtype">SIMD_M128&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>once prepare block has been called, you must call processSample exactly blockSize times, mapping the vector value in to the vector value out. </p>
<p>Convenience functions for single float and dual float are below. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a42572c7ca045c47660c91effd101b31a">FilterPayload::func</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a5214b86fecca5a3b820b08bc789ee35f">FilterPayload::qfuState</a>.</p>

<p class="reference">Referenced by <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ab8d48444d32cd02ed218776a0e5cdba4">Filter::processMonoSample()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a1aad8ae266f2f323132e8414254797de">Filter::processQuadSample()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ae3edce36cb488ab5dfc911265cc9e7ae">Filter::processStereoSample()</a>.</p>

</div>
</div>
<a id="ae8ece8404ddc3df4400951bcd6a2b90e" name="ae8ece8404ddc3df4400951bcd6a2b90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ece8404ddc3df4400951bcd6a2b90e">&#9670;&#160;</a></span>concludeBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void concludeBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>At the end of blockSize samples, and before resetting coefficients or the next call to prepareBlock, you need to call concludeBlock. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a0b56151486effa654591f0ae4106c8e6">FilterPayload::active</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a4060ca5aa1b55f315dd1a3aa21f2d7e1">FilterPayload::makers</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a5214b86fecca5a3b820b08bc789ee35f">FilterPayload::qfuState</a>.</p>

</div>
</div>
<a id="ab8d48444d32cd02ed218776a0e5cdba4" name="ab8d48444d32cd02ed218776a0e5cdba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d48444d32cd02ed218776a0e5cdba4">&#9670;&#160;</a></span>processMonoSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float processMonoSample </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience functions for mono channel if you dont want to manage simd </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a3cd5054af97c8e78764b4981e0305d13">Filter::processSample()</a>.</p>

</div>
</div>
<a id="ae3edce36cb488ab5dfc911265cc9e7ae" name="ae3edce36cb488ab5dfc911265cc9e7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3edce36cb488ab5dfc911265cc9e7ae">&#9670;&#160;</a></span>processStereoSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void processStereoSample </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>outL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>outR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience functions for stereo channel if you dont want to manage simd </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a3cd5054af97c8e78764b4981e0305d13">Filter::processSample()</a>.</p>

</div>
</div>
<a id="a1aad8ae266f2f323132e8414254797de" name="a1aad8ae266f2f323132e8414254797de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aad8ae266f2f323132e8414254797de">&#9670;&#160;</a></span>processQuadSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void processQuadSample </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>in</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>out</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience functions for quad channel if you dont want to manage simd. </p>
<p>But probably you are better biting the bullet and managing the simd outside </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a3cd5054af97c8e78764b4981e0305d13">Filter::processSample()</a>.</p>

</div>
</div>
<a id="a02fd73d861ef2e4aabb38c0c9ff82947" name="a02fd73d861ef2e4aabb38c0c9ff82947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fd73d861ef2e4aabb38c0c9ff82947">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the filter state. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#a02fd73d861ef2e4aabb38c0c9ff82947">FilterPayload::init()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>.</p>

</div>
</div>
<a id="ad20897c5c8bd47f5d4005989bead0e55" name="ad20897c5c8bd47f5d4005989bead0e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20897c5c8bd47f5d4005989bead0e55">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the filter registers; leaves the rest of the state intact. </p>

<p class="reference">References <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a91387e3bd5ec72538c8cc5759ae3e21c">Filter::payload</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html#ad20897c5c8bd47f5d4005989bead0e55">FilterPayload::reset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a33a300ef26cdb05b7b110fdc0dff4a06">Filter::prepareInstance()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a91387e3bd5ec72538c8cc5759ae3e21c" name="a91387e3bd5ec72538c8cc5759ae3e21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91387e3bd5ec72538c8cc5759ae3e21c">&#9670;&#160;</a></span>payload</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsst_1_1filtersplusplus_1_1details_1_1FilterPayload.html">details::FilterPayload</a> payload</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ae8ece8404ddc3df4400951bcd6a2b90e">Filter::concludeBlock()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a1a350d1ff0c7c85da0ab75c37a828d48">Filter::copyCoefficientsFromVoiceToVoice()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a303c04f07dc6a5e2264b3ad819cf9d27">Filter::displayName()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a9fa4e6a77176ab13076a2af0a957c76e">Filter::getBlockSize()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a16958e979fdfe0cd240f218f646f1b52">Filter::getFilterModel()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a713203944f561fcdb59a93d190a00ced">Filter::getModelConfiguration()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a02fd73d861ef2e4aabb38c0c9ff82947">Filter::init()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ae198aacaa2a4d55f3ece665390022137">Filter::makeCoefficients()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a206bb7e05b0f4d6eb38d43f05937c85b">Filter::makeConstantCoefficients()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#aa6518ed8373b1494d461f3b900dd0e5d">Filter::prepareBlock()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a33a300ef26cdb05b7b110fdc0dff4a06">Filter::prepareInstance()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a3cd5054af97c8e78764b4981e0305d13">Filter::processSample()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a0eea6576af602cfa469da4e41b6a7c70">Filter::provideAllDelayLines()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#aec4c2d0445932659ae203d2d13ed54bc">Filter::provideDelayLine()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a1e837634d6cb6e4d61b3d1a739a17358">Filter::requiresPreparation()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#ad20897c5c8bd47f5d4005989bead0e55">Filter::reset()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a4b65d36444ad7485b486fc877a14ba40">Filter::setActive()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a9e28a45379426fb18a6cee9d8e0771fc">Filter::setDriveType()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#aa54ecec72c96d310fae7c13d99d57e05">Filter::setFilterModel()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a9d0d98ac46914b071915df3cbb3cd18b">Filter::setModelConfiguration()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#acc1286366ff880145af13aa8f23b200b">Filter::setPassType()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a3aa4ebe01a2db1d1ada9aef3499cb086">Filter::setSampleRateAndBlockSize()</a>, <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#afcba9fb0fbece7899b8e1c93c7784d6a">Filter::setSlopeLevel()</a>, and <a class="el" href="structsst_1_1filtersplusplus_1_1Filter.html#a5edadbd99b490d94dd55f34cd2561720">Filter::setSubModelType()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="api_8h.html">api.h</a></li>
<li><a class="el" href="filter__impl_8h.html">filter_impl.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 27 2025 00:40:26 for sst-filters by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
